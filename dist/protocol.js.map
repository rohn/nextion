{"version":3,"sources":["../src/protocol.js"],"names":["read","trace","NextionProtocolClass","reset","reader","buf","slice","length","equals","delimiterBuffer","call","NextionProtocol","constructor","readers","byte","name","UInt8","eventCode","eventCodeMap","get","String","context","code","responseCode","responseCodeMap","touchEvent","pageId","releaseEvent","Boolean","touchCoordinate","touchCoordinateOnWake","stringData","value","buffer","toString","numericData","Int16LE","Object","keys","forEach","define","Result","hex","EventResult","data","ResponseResult","readUInt8","codeStr","result","has","nextionProtocol","_","isFunction","TypeError","delimiter","Buffer","from"],"mappings":"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","file":"protocol.js","sourcesContent":["import {createProtocol} from 'bin-protocol';\nimport {eventCodeMap, responseCodeMap} from './codes';\nimport _ from 'lodash/fp';\nimport debug_ from 'debug';\nimport {toHex} from './util';\n\n/**\n * @ignore\n */\nconst trace = debug_('trace:nextion:protocol');\n\n/**\n * @ignore\n * @todo document\n */\nconst NextionProtocolClass = createProtocol(function () {\n  // this is mostly here for the convenience of a 3p consumer.\n  const reset = this.reader.reset;\n  this.reader.reset = function (buf) {\n    if (buf.slice(buf.length - 3)\n        .equals(delimiterBuffer)) {\n      return reset.call(this, buf.slice(0, -3));\n    }\n    return reset.call(this, buf);\n  };\n});\n\n/**\n * A [bin-protocol](https://npmjs.com/package/bin-protocol) `Protocol` class\n * which decodes Nextion-speak.\n * @see https://npmjs.com/package/bin-protocol\n * @example\n * const protocolInstance = new NextionProtocol();\n */\nclass NextionProtocol {\n  /**\n   * Constructs a {@link NextionProtocol} instance.\n   */\n  constructor () {\n    return new NextionProtocolClass();\n  }\n}\n\n/**\n * Result of `stringData` response.\n * @typedef {Object} StringData\n * @property {string} value - String result value\n */\n\n/**\n * Result of `numericData` response.\n * @typedef {Object} NumericData\n * @property {number} value - Numeric result value\n */\n\n/**\n * Namespace of \"read\" functions which are supported by {@link NextionProtocol}.\n * @todo Document the shape of the event data\n * @private\n */\nconst readers = {\n  byte (name) {\n    this.UInt8(name);\n  },\n  eventCode () {\n    this.byte('code');\n    return eventCodeMap.get(String(this.context.code));\n  },\n  responseCode () {\n    this.byte('code');\n    return responseCodeMap.get(String(this.context.code));\n  },\n  touchEvent () {\n    this.pageId()\n      .byte('buttonId')\n      .byte('releaseEvent');\n    this.context.releaseEvent = Boolean(this.context.releaseEvent);\n  },\n  pageId () {\n    this.byte('pageId');\n  },\n  touchCoordinate () {\n    this.byte('xHigh')\n      .byte('xLow')\n      .byte('yHigh')\n      .byte('yLow')\n      .byte('releaseEvent');\n    this.context.releaseEvent = Boolean(this.context.releaseEvent);\n  },\n  touchCoordinateOnWake () {\n    this.touchCoordinate();\n  },\n  stringData () {\n    this.context.value = this.buffer.toString();\n  },\n  numericData () {\n    this.Int16LE('value');\n  }\n};\n\nObject.keys(readers)\n  .forEach(name => {\n    NextionProtocolClass.define(name, {\n      read: readers[name]\n    });\n  });\n\n/**\n * Generic response or event from Nextion device.\n * @abstract\n * @example\n * const result = new Result(0x01); // success\n */\nclass Result {\n  /**\n   * Creates a {@link Result}.\n   * @param {number} code - Decimal instruction code\n   */\n  constructor (code) {\n    /**\n     * Decimal representation of instruction code.\n     * @type {number}\n     */\n    this.code = code;\n  }\n\n  /**\n   * Hexadecimal representation of instruction code.\n   * @type {string}\n   */\n  get hex () {\n    return toHex(this.code);\n  }\n}\n\n/**\n * An \"event\" from a Nextion device.\n */\nclass EventResult extends Result {\n  /**\n   * Creates an EventResult.\n   * @param {number} code - Decimal instruction code\n   * @param {*} [data] - Any other data returned by result\n   */\n  constructor (code, data) {\n    super(code);\n\n    /**\n     * Human-readable short name of this event.\n     * @type {string}\n     */\n    this.name = eventCodeMap.get(String(code));\n\n    /**\n     * Any other data returned by result\n     * @type {*|void}\n     */\n    this.data = data;\n  }\n}\n\n/**\n * A response, either success or an error, from a command.\n */\nclass ResponseResult extends Result {\n  /**\n   * Creates a ResponseResult.\n   * @param {number} code - Decimal instruction code\n   * @param {*} [data] - Any other data returned by result\n   */\n  constructor (code, data) {\n    super(code);\n\n    /**\n     * Human-readable short name of this response.\n     * @type {string}\n     */\n    this.name = responseCodeMap.get(String(code));\n\n    /**\n     * Any other data returned by result\n     * @type {*|void}\n     */\n    this.data = data;\n  }\n}\n\n/**\n * Parse an event or response from a Nextion device.\n * @param {Buffer} buf - Raw `Buffer` from Nextion device\n * @returns {Result} - Parsed result\n * @throws {TypeError} When unknown data received from device\n * @private\n */\nexport function read (buf) {\n  const code = buf.readUInt8(0);\n  trace('Code:', toHex(code));\n  const codeStr = String(code);\n  let result;\n  if (responseCodeMap.has(codeStr)) {\n    result = new ResponseResult(code);\n  } else if (eventCodeMap.has(codeStr)) {\n    result = new EventResult(code);\n  }\n\n  if (result) {\n    const reader = nextionProtocol.read(buf.slice(1));\n    if (_.isFunction(reader[result.name])) {\n      result.data = reader[result.name]().result;\n    }\n    return result;\n  }\n\n  throw new TypeError(`Unknown data received: ${buf.toString()}`);\n}\n\n/**\n * This instance is used internally.\n * @type {NextionProtocol}\n * @private\n */\nexport const nextionProtocol = new NextionProtocol();\n\nexport {NextionProtocolClass as NextionProtocol};\n\n/**\n * This is the byte delimiter all Nextion data ends with.\n * @type {number[]}\n * @private\n */\nexport const delimiter = [\n  0xff,\n  0xff,\n  0xff\n];\n\n/**\n * Buffer wrapper of {@link delimiter}.\n * @private\n * @type {Buffer}\n */\nexport const delimiterBuffer = Buffer.from(delimiter);\n"]}