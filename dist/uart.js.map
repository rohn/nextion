{"version":3,"sources":["../src/uart.js"],"names":["DEFAULT_BAUD_RATE","DEFAULT_RETURN_COMMAND_RESULT","REQUEST_TIMEOUT","PORT_GUESS_REGEX","trace","debug","applyDefaults","_","defaults","returnCommandResult","baudRate","UART","EventEmitter","constructor","port","opts","TypeError","ready","on","data","result","type","name","codeByte","emit","listenerCount","err","checkPort","Promise","resolve","reject","Error","setValue","variableName","value","then","request","getValue","String","trim","write","Buffer","isBuffer","drain","send","command","concat","from","delimiterBuffer","commands","timeout","handler","clearTimeout","t","once","setTimeout","removeListener","catch","results","length","shift","bind","nextDelimiterIndex","buf","Array","forEach","byte","push","last","delimiter","setReturnCommandResult","commandValue","unbind","isFunction","close","fromSerial","serialPort","fromPort","portName","isObject","Serialport","assign","findPort","list","pipe","pluck","filter","test","head"],"mappings":";;;;;AAAA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;AACA;;;;AAEA;;;;;AAKO,MAAMA,gDAAoB,IAA1B;;AAEP;;;;;AAKO,MAAMC,wEAAgC,QAAtC;;AAEP;;;;;AAKO,MAAMC,4CAAkB,IAAxB;;AAEP;;;;;AAKA,MAAMC,mBAAmB,eAAzB;;AAEA;;;AAGA,MAAMC,QAAQ,qBAAO,oBAAP,CAAd;;AAEA;;;AAGA,MAAMC,QAAQ,qBAAO,cAAP,CAAd;;AAEA;;;;;;;AAOA,MAAMC,gBAAgBC,aAAEC,QAAF,CAAW;AAC/BC,uBAAqBR,6BADU;AAE/BS,YAAUV;AAFqB,CAAX,CAAtB;;AAKA;;;;;;;AAOA;;;;;;;;AAQO,MAAMW,IAAN,SAAmBC,oBAAnB,CAAgC;AACrC;;;;;AAKAC,cAAaC,IAAb,EAAmBC,OAAO,EAA1B,EAA8B;AAC5B;;AAEA,QAAI,CAAC,uBAAYD,IAAZ,CAAL,EAAwB;AACtB,YAAM,IAAIE,SAAJ,CAAc,yCAAd,CAAN;AACD;;AAED;;;;;AAKA,SAAKD,IAAL,GAAYT,cAAcS,IAAd,CAAZ;;AAEA;;;;;AAKA,SAAKD,IAAL,GAAYA,IAAZ;;AAEA;;;;AAIA,SAAKG,KAAL,GAAa,KAAb;;AAEA,SAAKC,EAAL,CAAQ,MAAR,EAAgBC,QAAQ;AACtB,UAAI;AACF,cAAMC,SAAS,oBAAKD,IAAL,CAAf;AACA,YAAIC,OAAOC,IAAP,KAAgB,OAApB,EAA6B;AAC3BhB,gBAAO,UAASe,OAAOE,IAAK,MAAKF,OAAOG,QAAS,UAAjD,EACEH,OAAOD,IADT;AAEA,eAAKK,IAAL,CAAU,OAAV,EAAmBJ,MAAnB;AACD,SAJD,MAIO,IAAI,KAAKK,aAAL,CAAmB,UAAnB,CAAJ,EAAoC;AACzCpB,gBAAO,aAAYe,OAAOE,IAAK,MAAKF,OAAOG,QAAS,GAApD;AACA,eAAKC,IAAL,CAAU,UAAV,EAAsBJ,MAAtB;AACD;AACF,OAVD,CAUE,OAAOM,GAAP,EAAY;AACZ,aAAKF,IAAL,CAAU,OAAV,EAAmBE,GAAnB;AACD;AACF,KAdD,EAeGR,EAfH,CAeM,SAfN,EAeiB,MAAM;AACnB,WAAKD,KAAL,GAAa,IAAb;AACD,KAjBH,EAkBGC,EAlBH,CAkBM,OAlBN,EAkBe,MAAM;AACjB,WAAKD,KAAL,GAAa,KAAb;AACD,KApBH;AAqBD;;AAED;;;;;AAKAU,cAAa;AACX,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAI,CAAC,KAAKb,KAAV,EAAiB;AACfa,eAAO,IAAIC,KAAJ,CAAU,mBAAV,CAAP;AACD;AACDF;AACD,KALM,CAAP;AAMD;;AAED;;;;;;;;;AASAG,WAAUC,YAAV,EAAwBC,KAAxB,EAA+B;AAC7B,WAAO,KAAKP,SAAL,GACJQ,IADI,CACC,MAAM;AACV,UAAID,UAAU,IAAd,EAAoB;AAClBA,gBAAQ,CAAR;AACD,OAFD,MAEO,IAAIA,UAAU,KAAd,EAAqB;AAC1BA,gBAAQ,CAAR;AACD;AACD,aAAO,KAAKE,OAAL,CAAc,GAAEH,YAAa,IAAGC,KAAM,EAAtC,CAAP;AACD,KARI,CAAP;AASD;;AAED;;;;;;AAMAG,WAAUf,IAAV,EAAgB;AACd,WAAO,KAAKK,SAAL,GACJQ,IADI,CACC,MAAM,KAAKC,OAAL,CAAc,OAAME,OAAOhB,IAAP,EAC7BiB,IAD6B,EACtB,EADE,CADP,CAAP;AAGD;;AAED;;;;;;;AAOAC,QAAOrB,IAAP,EAAa;AACX,WAAO,IAAIS,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAI,CAACW,OAAOC,QAAP,CAAgBvB,IAAhB,CAAL,EAA4B;AAC1B,eAAOW,OAAO,IAAId,SAAJ,CAAc,iBAAd,CAAP,CAAP;AACD;AACDZ,YAAM,UAAN,EAAkBe,IAAlB;AACA,WAAKL,IAAL,CAAU0B,KAAV,CAAgBrB,IAAhB,EAAsBO,OAAO;AAC3B,YAAIA,GAAJ,EAAS;AACP,iBAAOI,OAAOJ,GAAP,CAAP;AACD;AACD,aAAKZ,IAAL,CAAU6B,KAAV,CAAgBjB,OAAO;AACrB,cAAIA,GAAJ,EAAS;AACP,mBAAOI,OAAOJ,GAAP,CAAP;AACD;AACDG;AACD,SALD;AAMD,OAVD;AAWD,KAhBM,EAiBJM,IAjBI,CAiBC,MAAM;AACV/B,YAAM,QAAN,EAAgBe,QAAQ,gBAAxB;AACA,aAAO,IAAP;AACD,KApBI,CAAP;AAqBD;;AAED;;;;;;AAMAyB,OAAMC,UAAU,EAAhB,EAAoB;AAClBzC,UAAM,UAAN,EAAkByC,OAAlB;AACA,WAAO,KAAKL,KAAL,CAAWC,OAAOK,MAAP,CAAc,CAC9BL,OAAOM,IAAP,CAAYF,OAAZ,CAD8B,EAE9BG,yBAF8B,CAAd,CAAX,EAIJb,IAJI,CAIC,MAAM;AACV/B,YAAM,OAAN,EAAeyC,WAAW,gBAA1B;AACA,aAAO,IAAP;AACD,KAPI,CAAP;AAQD;;AAED;;;;;;;AAOAT,UAASa,WAAW,EAApB,EAAwBC,UAAUhD,eAAlC,EAAmD;AACjD,WAAO,KAAKyB,SAAL,GACJQ,IADI,CACC,MAAM;AACVc,iBAAW,GAAGH,MAAH,CAAUG,QAAV,CAAX;AACA,aAAO,0BAAWA,QAAX,EAAqBJ,WAAW;AACrCxC,cAAM,mBAAN;AACA,eAAO,IAAIuB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,gBAAMqB,UAAU/B,UAAU;AACxBf,kBAAM,UAAN,EAAkBe,MAAlB;AACAgC,yBAAaC,CAAb;AACA,mBAAOxB,QAAQT,MAAR,CAAP;AACD,WAJD;;AAMA,eAAKkC,IAAL,CAAU,UAAV,EAAsBH,OAAtB;;AAEA,gBAAME,IAAIE,WAAW,MAAM;AACzB,iBAAKC,cAAL,CAAoB,UAApB,EAAgCL,OAAhC;AACArB,mBAAO,IAAIC,KAAJ,CAAW,cAAamB,OAAQ,aAAhC,CAAP;AACD,WAHS,EAGPA,OAHO,CAAV;;AAKA,eAAKN,IAAL,CAAUC,OAAV,EACGY,KADH,CACS/B,OAAO;AACZ,iBAAK8B,cAAL,CAAoB,UAApB,EAAgCL,OAAhC;AACArB,mBAAOJ,GAAP;AACD,WAJH;AAKD,SAnBM,CAAP;AAoBD,OAtBM,CAAP;AAuBD,KA1BI,EA2BJS,IA3BI,CA2BCuB,WAAWT,SAASU,MAAT,KAAoB,CAApB,GACbD,QAAQE,KAAR,EADa,GAEbF,OA7BC,CAAP;AA8BD;;AAED;;;;;;;;;;AAUAG,OAAM/C,IAAN,EAAY;AACVA,WAAOA,QAAQ,KAAKA,IAApB;AACA,QAAIgD,qBAAqB,CAAzB;AACA,QAAIC,MAAM,EAAV;AACAjD,SAAKI,EAAL,CAAQ,MAAR,EAAgBC,QAAQ;AACtBf,YAAM,oBAAN,EAA4Be,IAA5B;AACA;AACA;AACA6C,YAAMjB,IAAN,CAAW5B,IAAX,EACG8C,OADH,CACWC,QAAQ;AACfH,YAAII,IAAJ,CAASD,IAAT;AACA,YAAI3D,aAAE6D,IAAF,CAAOL,GAAP,MAAgBM,oBAAUP,kBAAV,CAApB,EAAmD;AACjDA;AACD;AACD,YAAIA,uBAAuBO,oBAAUV,MAArC,EAA6C;AAC3CI,gBAAMtB,OAAOM,IAAP,CAAYgB,GAAZ,CAAN;AACA3D,gBAAM,QAAN,EAAgB2D,GAAhB;AACA,eAAKvC,IAAL,CAAU,MAAV,EAAkBuC,GAAlB;AACAA,gBAAM,EAAN;AACAD,+BAAqB,CAArB;AACD;AACF,OAbH;AAcD,KAlBD,EAmBG5C,EAnBH,CAmBM,OAnBN,EAmBeQ,OAAO;AAClB,WAAKF,IAAL,CAAU,OAAV,EAAmBE,GAAnB;AACD,KArBH,EAsBGR,EAtBH,CAsBM,OAtBN,EAsBe,MAAM;AACjB,WAAKM,IAAL,CAAU,YAAV;AACA,WAAKV,IAAL,GAAY,IAAZ;AACA,aAAO,KAAKA,IAAZ;AACD,KA1BH,EA2BGI,EA3BH,CA2BM,YA3BN,EA2BoBQ,OAAO;AACvB,WAAKF,IAAL,CAAU,OAAV,EAAmBE,GAAnB;AACD,KA7BH;;AA+BArB,UAAM,uBAAN;AACA,WAAO,KAAKuC,IAAL,CAAU,SAAV,EACJT,IADI,CACC,MAAM,KAAKmC,sBAAL,CAA4B,KAAKvD,IAAL,CAAUN,mBAAtC,CADP,EAEJ0B,IAFI,CAEC,MAAM;AACV,WAAKX,IAAL,CAAU,SAAV;AACA,aAAO,IAAP;AACD,KALI,CAAP;AAMD;;AAED;;;;;;;;;AASA8C,yBAAwBpC,QAAQ,QAAhC,EAA0C;AACxC,QAAIqC,YAAJ;;AAEA,YAAQrC,KAAR;AACE,WAAK,KAAL;AACA,WAAK,CAAL;AACA;AACA,WAAK,MAAL;AACEqC,uBAAe,CAAf;AACA;AACF,WAAK,CAAL;AACA,WAAK,IAAL;AACA;AACA,WAAK,QAAL;AACA;AACEA,uBAAe,CAAf;AAZJ;;AAeA,WAAO,KAAK3B,IAAL,CAAW,SAAQ2B,YAAa,EAAhC,EACJpC,IADI,CACC,MAAM;AACV,WAAKpB,IAAL,CAAUN,mBAAV,GAAgCyB,KAAhC;AACA7B,YAAO,+BAA8B6B,KAAM,GAA3C;AACA,aAAO,IAAP;AACD,KALI,CAAP;AAMD;;AAED;;;;;;AAMAsC,WAAU;AACR,UAAM1D,OAAO,KAAKA,IAAlB;AACA,SAAKA,IAAL,GAAY,IAAZ;AACA,WAAO,KAAKA,IAAZ;AACA,QAAIP,aAAEkE,UAAF,CAAa3D,KAAK4D,KAAlB,CAAJ,EAA8B;AAC5B,aAAO,oBAAK5D,KAAK4D,KAAL,CAAWb,IAAX,CAAgB/C,IAAhB,CAAL,IACJqB,IADI,CACC,MAAM;AACV,aAAKX,IAAL,CAAU,YAAV;AACA,eAAO,IAAP;AACD,OAJI,CAAP;AAKD;AACD,SAAKA,IAAL,CAAU,YAAV;AACA,WAAOI,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAED;;;;;;;AAOA,SAAO8C,UAAP,CAAmBC,UAAnB,EAA+B7D,OAAO,EAAtC,EAA0C;AACxC,WAAOa,QAAQC,OAAR,CAAgB,IAAIlB,IAAJ,CAASiE,UAAT,EAAqB7D,IAArB,CAAhB,CAAP;AACD;;AAED;;;;;;;;;;AAUA,SAAO8D,QAAP,CAAiBC,QAAjB,EAA2B/D,OAAO,EAAlC,EAAsC;AACpC,QAAIR,aAAEwE,QAAF,CAAWD,QAAX,CAAJ,EAA0B;AACxB/D,aAAO+D,QAAP;AACAA,iBAAWA,SAAShE,IAApB;AACD;;AAEDC,WAAOT,cAAcS,IAAd,CAAP;;AAEA,QAAI+D,QAAJ,EAAc;AACZ,aAAO,IAAIlD,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCzB,cAAO,iBAAgByE,QAAS,aAAhC,EAA8C/D,IAA9C;AACA,cAAM6D,aAAa,IAAII,oBAAJ,CAAeF,QAAf,EAAyB/D,IAAzB,EAA+BW,OAAO;AACvD,cAAIA,GAAJ,EAAS;AACP,mBAAOI,OAAOJ,GAAP,CAAP;AACD;AACDG,kBAAQ+C,UAAR;AACD,SALkB,CAAnB;AAMD,OARM,EASJzC,IATI,CASCyC,cAAc;AAClBvE,cAAO,8BAA6ByE,QAAS,GAA7C;AACA,eAAOnE,KAAKgE,UAAL,CAAgBC,UAAhB,EAA4BrE,aAAE0E,MAAF,CAASlE,IAAT,EAAe,EAAC+D,QAAD,EAAf,CAA5B,CAAP;AACD,OAZI,CAAP;AAaD,KAdD,MAcO;AACL,aAAOnE,KAAKuE,QAAL,GACJ/C,IADI,CACC2C,YAAY;AAChB,YAAI,CAACA,QAAL,EAAe;AACb,gBAAM,IAAI/C,KAAJ,CAAU,iCAAV,CAAN;AACD;AACD,eAAOpB,KAAKkE,QAAL,CAAcC,QAAd,EAAwB/D,IAAxB,CAAP;AACD,OANI,CAAP;AAOD;AACF;;AAED;;;;;;AAMA,SAAOgC,IAAP,CAAajC,IAAb,EAAmBC,OAAO,EAA1B,EAA8B;AAC5B,WAAO,uBAAYD,IAAZ,IACHH,KAAKgE,UAAL,CAAgB7D,IAAhB,EAAsBC,IAAtB,CADG,GAEHJ,KAAKkE,QAAL,CAAc/D,IAAd,EAAoBC,IAApB,CAFJ;AAGD;;AAED;;;;;;AAMA,SAAOmE,QAAP,GAAmB;AACjB,WAAO,oBAAKF,qBAAWG,IAAhB,IACJhD,IADI,CACC5B,aAAE6E,IAAF,CAAO7E,aAAE8E,KAAF,CAAQ,SAAR,CAAP,EACJ9E,aAAE+E,MAAF,CAASR,YAAY3E,iBAAiBoF,IAAjB,CAAsBT,QAAtB,CAArB,CADI,EACmDvE,aAAEiF,IADrD,CADD,CAAP;AAGD;AA1XoC;QAA1B7E,I,GAAAA,I","file":"uart.js","sourcesContent":["import {EventEmitter} from 'events';\nimport Serialport from 'serialport';\nimport _ from 'lodash/fp';\nimport pMapSeries from 'p-map-series';\nimport pify from 'pify';\nimport debug_ from 'debug';\n\nimport {delimiter, delimiterBuffer, read} from './protocol';\nimport {isValidPort} from './util';\n\n/**\n * Factory default baud rate of Nextion is 9600\n * @private\n * @type {number}\n */\nexport const DEFAULT_BAUD_RATE = 9600;\n\n/**\n * This tells the Nextion to return a command result even if command succeeded\n * @private\n * @type {string}\n */\nexport const DEFAULT_RETURN_COMMAND_RESULT = 'always';\n\n/**\n * Timeout in ms we should wait for response from Nextion for various requests\n * @private\n * @type {number}\n */\nexport const REQUEST_TIMEOUT = 1000;\n\n/**\n * We use this to find a reasonable serial port\n * @private\n * @type {RegExp}\n */\nconst PORT_GUESS_REGEX = /usb|acm|^com/i;\n\n/**\n * @ignore\n */\nconst trace = debug_('trace:nextion:UART');\n\n/**\n * @ignore\n */\nconst debug = debug_('nextion:UART');\n\n/**\n * Applies defaults to an object\n * @param {NextionOptions} obj - Defaults are applied to this object\n * @returns {NextionOptions} Options w/ defaults applied\n * @function\n * @private\n */\nconst applyDefaults = _.defaults({\n  returnCommandResult: DEFAULT_RETURN_COMMAND_RESULT,\n  baudRate: DEFAULT_BAUD_RATE\n});\n\n/**\n * Whether or not to expect the Nextion device to return success/failure codes\n * after each serial command.  Defaults to \"always\".\n * @typedef {string|boolean|number} ReturnCommandResultValue\n * @private\n */\n\n/**\n * Wraps a SerialPort or similar object; provides convenience methods for\n * interaction with a Nextion over UART.\n * @emits {error} When {@link UART#port} emits `error` or is unexpectedly\n *   disconnected, or when we receive unknown data from the device.\n * @emits {close} When {@link UART#close} successfully completes\n * @extends {EventEmitter}\n */\nexport class UART extends EventEmitter {\n  /**\n   * Sets some default options\n   * @param {EventEmitter|Duplex} port - Serial port interface\n   * @param {NextionOptions} [opts={}] - Options\n   */\n  constructor (port, opts = {}) {\n    super();\n\n    if (!isValidPort(port)) {\n      throw new TypeError('\"port\" must be a Serialport-like object');\n    }\n\n    /**\n     * Options\n     * @type {NextionOptions}\n     * @private\n     */\n    this.opts = applyDefaults(opts);\n\n    /**\n     * Internal serial port object\n     * @type {Serialport|Duplex|*}\n     * @private\n     */\n    this.port = port;\n\n    /**\n     * `true` once we've successfully began listening via {@link UART#bind}.\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    this.on('data', data => {\n      try {\n        const result = read(data);\n        if (result.type === 'event') {\n          debug(`Event \"${result.name}\" (${result.codeByte}); data:`,\n            result.data);\n          this.emit('event', result);\n        } else if (this.listenerCount('response')) {\n          debug(`Response \"${result.name}\" (${result.codeByte})`);\n          this.emit('response', result);\n        }\n      } catch (err) {\n        this.emit('error', err);\n      }\n    })\n      .on('connect', () => {\n        this.ready = true;\n      })\n      .on('close', () => {\n        this.ready = false;\n      });\n  }\n\n  /**\n   * Asserts readiness of port\n   * @returns {Promise<void,Error>} Rejected if port not ready\n   * @private\n   */\n  checkPort () {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) {\n        reject(new Error('Device not ready!'));\n      }\n      resolve();\n    });\n  }\n\n  /**\n   * Set variable `variableName` to value `value`.\n   * Boolean values `true` and `false` become `1` and `0`, respectively.\n   * @param {string} variableName - Name of variable, component, system var,\n   *   page, etc.\n   * @param {*} [value] - Will be coerced to a string.\n   * @returns {Promise<ResponseResult, Error>} Result of setting value, or\n   *   {@link Error} if device is not ready.\n   */\n  setValue (variableName, value) {\n    return this.checkPort()\n      .then(() => {\n        if (value === true) {\n          value = 1;\n        } else if (value === false) {\n          value = 0;\n        }\n        return this.request(`${variableName}=${value}`);\n      });\n  }\n\n  /**\n   * Gets a value\n   * @param {string} name - Name; can be `varName.val` or `component.txt`, etc.\n   * @returns {Promise<ResponseResult<StringData|NumericData>,Error>} String or\n   *   numeric data response (depending on variable's type)\n   */\n  getValue (name) {\n    return this.checkPort()\n      .then(() => this.request(`get ${String(name)\n        .trim()}`));\n  }\n\n  /**\n   * Wraps port's `write()` in a {@link Promise}\n   * @param {Buffer} data - Data to write\n   * @returns {Promise<UART, TypeError>} UART instance, or {@link TypeError} if\n   *   `data` is not a {@link Buffer}.\n   * @private\n   */\n  write (data) {\n    return new Promise((resolve, reject) => {\n      if (!Buffer.isBuffer(data)) {\n        return reject(new TypeError('Expected Buffer'));\n      }\n      trace('Writing:', data);\n      this.port.write(data, err => {\n        if (err) {\n          return reject(err);\n        }\n        this.port.drain(err => {\n          if (err) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    })\n      .then(() => {\n        trace('Wrote:', data || '(empty string)');\n        return this;\n      });\n  }\n\n  /**\n   * Sends a raw command; does not wait for response.\n   * @param {string} [command] - Raw ASCII command, or nothing at all\n   * @todo this might need a semaphore.\n   * @returns {Promise<UART>} This UART instance\n   */\n  send (command = '') {\n    trace('Sending:', command);\n    return this.write(Buffer.concat([\n      Buffer.from(command),\n      delimiterBuffer\n    ]))\n      .then(() => {\n        trace('Sent:', command || '(empty string)');\n        return this;\n      });\n  }\n\n  /**\n   * Makes a request to a Nextion device, expecting a response.\n   * @param {string[]|string} commands - Command(s) to execute\n   * @param {number} [timeout=1000] - How long to wait for response (in ms)\n   * @returns {Promise<ResponseResult[]|ResponseResult,Error>} Result or array\n   *   of results, or {@link Error} if device is not ready.\n   */\n  request (commands = [], timeout = REQUEST_TIMEOUT) {\n    return this.checkPort()\n      .then(() => {\n        commands = [].concat(commands);\n        return pMapSeries(commands, command => {\n          debug('Beginning request');\n          return new Promise((resolve, reject) => {\n            const handler = result => {\n              debug('Received', result);\n              clearTimeout(t);\n              return resolve(result);\n            };\n\n            this.once('response', handler);\n\n            const t = setTimeout(() => {\n              this.removeListener('response', handler);\n              reject(new Error(`Timeout of ${timeout}ms exceeded`));\n            }, timeout);\n\n            this.send(command)\n              .catch(err => {\n                this.removeListener('response', handler);\n                reject(err);\n              });\n          });\n        });\n      })\n      .then(results => commands.length === 1\n        ? results.shift()\n        : results);\n  }\n\n  /**\n   * Begins listening for data on the open serial port.\n   * If an event is emitted from the Nextion device, an event with a\n   * human-readable name will be emitted, along with any extra data, if\n   * present.\n   * Errors bubble up from the serial port object thru the UART instance.\n   * @param {EventEmitter|Duplex} [port] - `Serialport`-like\n   *   object to listen for data and errors on.  Defaults to {@link UART#port}.\n   * @returns {Promise<UART>} This UART instance\n   */\n  bind (port) {\n    port = port || this.port;\n    let nextDelimiterIndex = 0;\n    let buf = [];\n    port.on('data', data => {\n      trace('Received raw data:', data);\n      // this is torn from serialport's byte delimiter parser, considering\n      // we aren't ensured a Serialport object.\n      Array.from(data)\n        .forEach(byte => {\n          buf.push(byte);\n          if (_.last(buf) === delimiter[nextDelimiterIndex]) {\n            nextDelimiterIndex++;\n          }\n          if (nextDelimiterIndex === delimiter.length) {\n            buf = Buffer.from(buf);\n            trace('Parsed', buf);\n            this.emit('data', buf);\n            buf = [];\n            nextDelimiterIndex = 0;\n          }\n        });\n    })\n      .on('error', err => {\n        this.emit('error', err);\n      })\n      .on('close', () => {\n        this.emit('disconnect');\n        this.port = null;\n        delete this.port;\n      })\n      .on('disconnect', err => {\n        this.emit('error', err);\n      });\n\n    debug('Configuring device...');\n    return this.send('sleep=0')\n      .then(() => this.setReturnCommandResult(this.opts.returnCommandResult))\n      .then(() => {\n        this.emit('connect');\n        return this;\n      });\n  }\n\n  /**\n   * Tell the Nextion device to wait (default) or not wait for responses when\n   * requests are made.\n   * @param {string|number|boolean} [value='always'] - `false`, `0` or `'none'`\n   *   to disable waiting for responses; `true`, `1` or `'always'` to enable\n   *   waiting for responses.\n   * @private\n   * @returns {Promise<UART>} This UART instance\n   */\n  setReturnCommandResult (value = 'always') {\n    let commandValue;\n\n    switch (value) {\n      case false:\n      case 0:\n      // falls through\n      case 'none':\n        commandValue = 0;\n        break;\n      case 3:\n      case true:\n      // falls through\n      case 'always':\n      default:\n        commandValue = 3;\n    }\n\n    return this.send(`bkcmd=${commandValue}`)\n      .then(() => {\n        this.opts.returnCommandResult = value;\n        debug(`returnCommandResult is now \"${value}\"`);\n        return this;\n      });\n  }\n\n  /**\n   * Stops listening on the serial port, closes it, destroys the reference,\n   * kills a kitten, etc.\n   * Use {@link Nextion#close} instead.\n   * @returns {Promise<UART>} This UART instance\n   */\n  unbind () {\n    const port = this.port;\n    this.port = null;\n    delete this.port;\n    if (_.isFunction(port.close)) {\n      return pify(port.close.bind(port))()\n        .then(() => {\n          this.emit('disconnect');\n          return this;\n        });\n    }\n    this.emit('disconnect');\n    return Promise.resolve(this);\n  }\n\n  /**\n   * Given a {@link Serialport}-like object, create a {@link UART} wrapper.\n   * Synchronous, but returns a {@link Promise} for consistency.\n   * @param {Serialport|Duplex|*} serialPort - {@link Serialport}-like object\n   * @param {NextionOptions} [opts={}] - Options\n   * @returns {Promise<UART>} New {@link UART} instance\n   */\n  static fromSerial (serialPort, opts = {}) {\n    return Promise.resolve(new UART(serialPort, opts));\n  }\n\n  /**\n   * Given a serial port name or path, or object containing one, create a\n   * {@link Serialport} instance, open the serial port, then return a {@link\n    * UART} instance. If no port name is present, we'll try to autodetect the\n   * port.\n   * @param {string|NextionOptions} [portName] - Serial port name or path, or\n   *   options\n   * @param {NextionOptions} [opts={}] - Options\n   * @returns {Promise<UART>} New {@link UART} instance\n   */\n  static fromPort (portName, opts = {}) {\n    if (_.isObject(portName)) {\n      opts = portName;\n      portName = portName.port;\n    }\n\n    opts = applyDefaults(opts);\n\n    if (portName) {\n      return new Promise((resolve, reject) => {\n        debug(`Opening port \"${portName}\" with opts`, opts);\n        const serialPort = new Serialport(portName, opts, err => {\n          if (err) {\n            return reject(err);\n          }\n          resolve(serialPort);\n        });\n      })\n        .then(serialPort => {\n          debug(`Opened connection to port \"${portName}\"`);\n          return UART.fromSerial(serialPort, _.assign(opts, {portName}));\n        });\n    } else {\n      return UART.findPort()\n        .then(portName => {\n          if (!portName) {\n            throw new Error('Could not find a serial device!');\n          }\n          return UART.fromPort(portName, opts);\n        });\n    }\n  }\n\n  /**\n   * Convenience wrapper of {@link UART.fromPort} and {@link UART.fromSerial}.\n   * @param {string|Duplex|Serialport} [port] - Port name or object\n   * @param {NextionOptions} [opts] - Options\n   * @returns {Promise<UART>} New {@link UART} instance\n   */\n  static from (port, opts = {}) {\n    return isValidPort(port)\n      ? UART.fromSerial(port, opts)\n      : UART.fromPort(port, opts);\n  }\n\n  /**\n   * Tries to find a device on a serial/COM port.\n   * @returns {Promise<string|void>} - Name/path of promising serial port, if\n   *   any\n   * @private\n   */\n  static findPort () {\n    return pify(Serialport.list)()\n      .then(_.pipe(_.pluck('comName'),\n        _.filter(portName => PORT_GUESS_REGEX.test(portName)), _.head));\n  }\n}\n"]}